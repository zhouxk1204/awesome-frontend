# 事件委托原理

## 📝 概要

事件委托（Event Delegation）是一种利用 **事件冒泡机制** 来减少事件监听器数量、提高性能的 DOM 事件处理方式。

## 📌 核心知识点

- **事件冒泡是事件委托的基础**：事件先触发目标元素，再逐层向上冒泡直至 `document`。

- 委托本质：**把子元素的事件交给父容器监听**，通过 `event.target` 判断实际触发者。

- 最常见的用途：大量类似子节点的点击、输入、hover 事件统一处理。

- 优点：减少监听器数量、节省内存、减少重复绑定、动态元素自动生效。

- 委托适合**冒泡事件**（如 click、input、keyup、change*（需注意兼容性））。

- 不适合不冒泡的事件（如 scroll、blur/focus*（可用 focusin/out 替代））。

## 💻 示例代码

```html
<ul id="list">
  <li data-id="1">Item 1</li>
  <li data-id="2">Item 2</li>
  <li data-id="3">Item 3</li>
</ul>

<script>
const list = document.getElementById('list');

list.addEventListener('click', (e) => {
  // 判断事件来源是否为 li
  const li = e.target.closest('li');
  if (!li) return;
  console.log('Clicked item id =', li.dataset.id);
});
</script>
```

### 为什么能工作？

当你点击 `<li>`：

```
li → ul → body → document （冒泡路径）
```

`ul` 能监听到所有来自其子元素的点击事件，因此只需一个监听器。

## ⚠️ 常见误区

- ❌ **误区：所有事件都能委托** → scroll、mouseenter、blur 等不冒泡，不适合。

- ❌ **误区：使用事件委托会改变事件 target** → target 始终是「实际触发元素」，不会变。

- ❌ **误区：委托只能绑定在父元素上** → 也可以委托在 `document` 或 `window`。

- ❌ **误区：委托比直接绑定慢** → 大多数情况下委托更快，因为监听器更少。

## 🎯 适用场景

- 大型列表、动态渲染的节点（如虚拟 DOM 之前的 jQuery 时代）。

- 表格（table）中大量 cell 的点击、高亮处理。

- 删除项、选中项、展开收起等 UI 行为。

- 输入事件快照、节流、日志采集等「父级统一捕获」。

## 🔗 关联笔记

- [[浏览器事件模型]]

- [[React DOM 事件委托机制]]

- [[react_stopPropagation_与_isPropagationStopped_源码解析]]

## 🏷️ 标签

# javascript #事件委托 #DOM #前端基础
