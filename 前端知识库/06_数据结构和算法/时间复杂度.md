# 时间复杂度 （Time Complexity）

## 📝 概要

时间复杂度描述算法运行时间随输入规模 n 增长的趋势。  
核心：**看代码一共执行了多少“基本操作”**，然后把低阶项和常数去掉。

---

## 📌 1. 常见时间复杂度与 n 的计算推导

---

## 🔹 O(1) —— 常数时间

无论 n 多大，执行次数都恒定。

```ts
const getFirstElement = (arr) => arr[0];
```

### ➤ 为什么是 O(1)？

- 只执行一次取值操作。

- 与 n 无关。

- 不需要进行 n 次循环。

**结论：O(1)**。

---

## 🔹 O(n) —— 线性时间

遍历一次数组，就是 n 次操作。

```ts
for (let i = 0; i < arr.length; i++) {
  total += arr[i];
}
```

### ➤ n 的计算过程（核心）

假设数组长度 = **n**

循环次数：

```text
i = 0 → 执行 1 次
i = 1 → 执行 1 次
...
i = n-1 → 执行 1 次
```

总次数：

```text
1 + 1 + 1 + ... + 1（共 n 次） = n
```

**结论：O(n)**

---

## 🔹 O(log n) —— 对数时间（以二分查找为例）

```ts
while(left <= right) {
  mid = (left + right) / 2
  // ...
}
```

### ➤ n 的计算过程（核心）

每次循环，都把问题规模砍掉一半：

```text
n → n/2 → n/4 → n/8 → ...
```

假设循环进行了 k 次，则：

```text
n / 2^k = 1
```

求 k：

```text
n = 2^k
k = log₂ n
```

**结论：循环 log₂ n 次，即 O(log n)**。

---

## 🔹 O(n log n) —— 排序常见（如快速排序、归并排序）

为什么很多排序是 O(n log n)？  
因为：

- **log n**：递归层数（每次分成两半）

- **n**：每层需要处理 n 个元素

### ➤ n 的计算过程拆解

1. 分治树高度：

    ```text
    n → n/2 → n/4 → ... → 1
    递归深度 = log₂ n
    ```

2. 每一层处理所有数据 = n

总操作：

```text
n * log n
```

**结论：O(n log n)**

---

## 🔹 O(n²) —— 双重循环（重点部分）

示例：冒泡排序

```ts
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n - i - 1; j++) {
    // ...
  }
}
```

### ➤ n 的计算过程（完整推导）

外层循环执行 n 次：

```text
i = 0 → 内层执行 (n-1) 次
i = 1 → 内层执行 (n-2) 次
i = 2 → 内层执行 (n-3) 次
...
i = n-1 → 内层执行 0 次
```

总次数：

```text
(n-1) + (n-2) + (n-3) + ... + 1 + 0
```

这是一个等差数列：

首项 = 0  
末项 = (n-1)  
项数 = n

求和公式：

```text
S = n * (n - 1) / 2
```

忽略常数与低阶项：

```text
S ≈ n² / 2 → O(n²)
```

**结论：O(n²)**

---

## 🔹 O(n³) —— 三重循环（推导方式同 n²）

```ts
for (i from 0 → n) {
  for (j from 0 → n) {
    for (k from 0 → n) {
      // ...
    }
  }
}
```

### ➤ n 的计算过程

每层循环执行 n 次：

```text
总次数 = n * n * n = n³
```

**结论：O(n³)**。

---

## 🔹 O(2ⁿ) —— 指数时间（以斐波那契为例）

```ts
f(n) = f(n-1) + f(n-2)
```

### ➤ n 的计算过程

每次递归分成两棵子树：

```text
           f(n)
         /     \
     f(n-1)   f(n-2)
     /   \
f(n-2) f(n-3)
```

随着 n 增加，节点数量接近：

```text
2ⁿ
```

**结论：O(2ⁿ)**（非常慢）

---

## 🔹 O(n!) —— 阶乘时间（例如全排列）

```ts
function permute(nums) {
  // ...
}
```

### ➤ n 的计算过程

- 第一个位置有 n 种选择

- 第二个位置有 (n-1) 种

- …

- 最后 1 种

总次数：

```text
n * (n-1) * (n-2) * ... * 1 = n!
```

**结论：O(n!)**

---

## 📌 对照表（含 n 的增长意义）

|复杂度|n = 10|n = 20|含义|
|---|---|---|---|
|O(1)|1|1|固定|
|O(log n)|3|4|很快|
|O(n)|10|20|线性|
|O(n log n)|30|80|常见排序|
|O(n²)|100|400|双层循环|
|O(n³)|1000|8000|三层循环|
|O(2ⁿ)|1024|1,048,576|爆炸|
|O(n!)|3,628,800|~2.4e18|灾难|

---

## 🔗 关联笔记

- [[空间复杂度]]

## 🏷️ 标签

#算法 #大O #时间复杂度 #复杂度分析 #前端基础 #数据结构
