# 空间复杂度（Space Complexity）

## 📝 概要

空间复杂度用于衡量一个算法在运行过程中 **额外占用多少内存**，以及这些占用如何随着输入规模 n 增长而变化。

它关注的是算法运行时“临时申请”的空间，而非输入本身占用的空间。

---

## 📌 核心知识点（图解 + 深入解释）

---

### 🧠 1. 什么算空间？（非常关键）

空间复杂度只统计 **额外申请的空间**：

```text
包含：
  ✔ 临时变量
  ✔ 数组 / 对象 / Map / Set
  ✔ 函数调用栈（特别是递归）
  ✔ 缓存表（如动态规划）

不包含：
  ✖ 输入数据本身占用的空间
  ✖ 常量级的环境开销
```

图解：

```text
┌────────────────────────────┐
│ 输入数组 arr: [1,2,3...]   │  ❌ 不算空间复杂度
└────────────────────────────┘

┌────────────────────────────┐
│ 我临时创建了 temp = []      │ ✔ 算空间复杂度
└────────────────────────────┘
```

---

### 🧊 2. 常见空间复杂度曲线

#### **O(1)（常数空间）**

额外空间始终固定，不随 n 变化。

```text
空间： ■ （固定大小）

n=10 → ■
n=1M → ■
```

适用于：使用固定数量变量，无额外数组结构。

---

#### **O(n)（线性空间）**

空间与 n 成正比增长。

```text
n = 1  → ■
n = 2  → ■■
n = 4  → ■■■■
n = 8  → ■■■■■■■■
```

典型场景：

- 创建与输入同规模的新数组

- DFS 递归深度为 n（如链表）

---

#### **O(n²)（二维空间）**

常见于矩阵、二维 DP。

图解（n=3）：

```text
■■■
■■■
■■■
```

n=4：

```text
■■■■
■■■■
■■■■
■■■■
```

空间随 n 的平方增长，非常昂贵。

---

#### **O(log n)（对数空间）**

通常来自递归调用栈深度。

```text
递归层级：
n → n/2 → n/4 → n/8 → 1

堆栈高度：
log₂ n
```

典型：二分查找的递归写法。

---

#### **O(n log n)**

典型来自：

- 分治（log n 层）

- 每层需要 O(n) 缓冲区（如归并排序）

图解：

```text
log n 层
每层占用 n 空间
总空间 = n log n
```

---

## 💻 示例代码（分复杂度讲解 + 可视化）

---

### **O(1) — 常数空间**

```js
function getFirst(arr) {
  let x = 0;     // 常量空间
  return arr[0];
}
```

图：

```text
额外空间：■（固定）
```

---

### **O(n) — 线性空间**

```js
function copyArray(arr) {
  const result = [];
  for (let v of arr) {
    result.push(v); // arr 越大，result 越大
  }
  return result;
}
```

图：

```text
n 个元素 → result 使用 n 空间
■■■■■■■■■■
```

---

### **O(n²) — 创建矩阵**

```js
function createMatrix(n) {
  const matrix = [];
  for (let i = 0; i < n; i++) {
    matrix[i] = new Array(n).fill(0);
  }
  return matrix;
}
```

图示（n=4）：

```text
■■■■
■■■■
■■■■
■■■■
```

---

### **O(log n) — 二分查找的递归**

```js
function binarySearch(arr, target, left, right) {
  if (left > right) return -1;

  const mid = Math.floor((left + right) / 2);

  if (arr[mid] === target) return mid;

  if (target < arr[mid])
    return binarySearch(arr, target, left, mid - 1);  // 栈深度 log n
  else
    return binarySearch(arr, target, mid + 1, right);
}
```

图解：

```text
执行路径：
(16) → (8) → (4) → (2) → (1)
层数 = log₂(n)
```

---

### **O(n log n) — 归并排序（空间取决于辅助数组）**

```js
function mergeSort(arr) {
  if (arr.length < 2) return arr;
  const mid = Math.floor(arr.length / 2);

  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right); // 需要创建结果数组 → O(n)
}
```

图解：

```text
分治层数： log n
每层空间： n

总空间： n log n
```

---

## ⚠️ 常见误区（加图解）

---

### ❌ 误区 1：递归只影响时间，不影响空间

图解：

```text
调用栈：
fib(5)
 └ fib(4)
    └ fib(3)
       └ fib(2)
          └ ...
```

每一层函数都占用栈 → 空间复杂度随深度增长。

---

### ❌ 误区 2：循环一定会增加空间

循环本身不占空间：

```text
for(...){}  → 不分配额外数组 → O(1)
```

关键是：你有没有在循环中创建新空间。

---

### ❌ 误区 3：输入数据算空间复杂度

不算！

```text
输入 arr = [1,2,3]   ❌ 不算
复制出的 newArr     ✔ 算
```

---

## 🎯 适用场景（扩展详细）

- 评估算法是否能跑在 **内存受限环境（小程序/移动端）**

- 优化 **动态规划** 时的重要指标（如降维 DP）

- 判断是否可能导致 **递归栈溢出**

- 在处理图/树结构时，评估 DFS、BFS 的栈/队列占用

- 面试算法题的重要评分项

---

## 🔗 关联笔记（补充更细分类）

- [[时间复杂度]]

---

## 🏷️ 标签

#javascript #算法 #bigO #复杂度分析 #空间复杂度 #图解 #数据结构
